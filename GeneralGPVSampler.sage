# Here I am going to implement a general GPV sampler for any number field,
# using LLL. Again the correctness is not guaranteed unless the std is
# large enough.

# Note: I can just use MyLatticeSampler to do it.

# Dependencies:
# MyLatticeSampler
# embedding_matrix

class GeneralGPVSampler:
    """
    GPV sampler for orders of form Z[\alpha].
    """
    def __init__(self,K, a, sigma = 1, prec = 500):
        self.K = K
        self._degree = K.degree()
        self.a = a
        self.z = K.gen
        self.g = K.defining_polynomial()
        self.f = a.minpoly()
        self.sigma = sigma
        self._disc = K.disc()
        self._tot_real = K.is_totally_real()
        w = [a**i for i in range(self._degree)]

        self.A = embedding_matrix(w,K,prec = prec)
        A = embedding_matrix(w,K,prec = 1000,totally_real = self._tot_real)
        from mpmath import *
        mp.dps = 60
        AA = mp.matrix([list(p) for p in list(A)])
        dv = (abs(det(AA)))**(1/self._degree)
        self._dv = dv

        self.final_sigma = dv*self.sigma

        self.D = MyLatticeSampler(self.A, sigma = self.final_sigma)

    def __repr__(self):
        return  "GPV sampler from the order generated by an element with minimal polynomial %s and sigma = %s"%(self.f, self.sigma)

    def set_sigma(self,sig):
        self.final_sigma = sig

    def disc(self):
        return self._disc

    def degree(self):
        return self._degree

    def dv(self):
        return self._dv

    def __call__(self, coordinate = True):
        return self.D(coordinate = coordinate) # call the lattice sampler.
